<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementation ¬∑ Multiscale Heterogeneous Catalysis</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Multiscale Heterogeneous Catalysis</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Macro Scale</span><ul><li><a class="tocitem" href="../../macro/assembly/">Assembly</a></li><li><a class="tocitem" href="../../macro/solver/">Solver</a></li></ul></li><li><span class="tocitem">Micro Scale</span><ul><li><a class="tocitem" href="../theory/">Theory</a></li><li class="is-active"><a class="tocitem" href>Implementation</a><ul class="internal"><li><a class="tocitem" href="#Structs"><span>Structs</span></a></li><li><a class="tocitem" href="#Assembly"><span>Assembly</span></a></li><li><a class="tocitem" href="#Micro-Solver"><span>Micro Solver</span></a></li><li><a class="tocitem" href="#Micro-Source/Sink"><span>Micro Source/Sink</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../utils/utils/">Utils</a></li><li><a class="tocitem" href="../../examples/run/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Micro Scale</a></li><li class="is-active"><a href>Implementation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implementation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/koehlerson/Catalyst/blob/master/docs/src/micro/implementation.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Structs"><a class="docs-heading-anchor" href="#Structs">Structs</a><a id="Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Structs" title="Permalink"></a></h2><p>Suitable datastructures are developed that hold as their fields all information about the microstructure.  In case of the simplified, linerized sink term <code>CatalystStateODE</code> can be used to store various numbers associated with the catalyst state.  When a PDE description of the microscale is used <code>CatalystStatePDE</code> should be used. This struct assembles by a given micro diffusion the corresponding linear operators of the micro scale and optionally assembles in each <code>catalyst_update!</code> call the nonlinear parts if <code>:nonlinear</code> is passed as the <code>microcomp_type</code>. </p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.CatalystStateODE" href="#Catalyst.CatalystStateODE"><code>Catalyst.CatalystStateODE</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CatalystStateODE(D_i, k·µß, k, h, r, V, A, Œît, coeff, c·µß_old)</code></pre><p>instantiates a <code>CatalystStateODE</code> struct holding all necessary values for the simplified microscale formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.CatalystStatePDE" href="#Catalyst.CatalystStatePDE"><code>Catalyst.CatalystStatePDE</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CatalystStatePDE(D_i, k_Œ≥, mesh, Q, k‚Çô)</code></pre><p>constructs a <code>CatalystStatePDE</code> struct that stores all information about the microstructure. Therefore, assembles also the linear diffusion and mass matrices that are stored in <code>M</code>, <code>K</code> and their associated sum in <code>A=K+k_Œ≥*M</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/Catalyst/blob/705a6bf4ffec26868623e8b5b6be0dd001b764a2/src/micro.jl#L42-L46">source</a></section></article><h2 id="Assembly"><a class="docs-heading-anchor" href="#Assembly">Assembly</a><a id="Assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly" title="Permalink"></a></h2><p>Most of the assembly is handled while constructing the corresponding CatalystState struct. However, in case of a nonlinear computation the nonlinear parts, i.e. the Jacobian of the residual has to be assembled in each newton iteration, due to its nonlinear nature.</p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.assemble_nonlinear_micro_global!" href="#Catalyst.assemble_nonlinear_micro_global!"><code>Catalyst.assemble_nonlinear_micro_global!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function assemble_nonlinear_micro_global!(K::SparseMatrixCSC{Float64,Int64}, f::Array{Float64,1}, dh::DofHandler, cv::CellScalarValues, c::Array{Float64,1}, Œît, D, Q, k‚Çô, c‚Åø, ùêÄ::SparseMatrixCSC{Float64,Int64})</code></pre><p>Assembles only the nonlinear part of the jacobian, so needs to add the linear part after nonlinear assemble, i.e.  assemble jacobi K, add mass matrix M and Diffusion Matrix Catalyst.K (ùêÄ) on top </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/Catalyst/blob/705a6bf4ffec26868623e8b5b6be0dd001b764a2/src/micro.jl#L264-L271">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Care the interface</header><div class="admonition-body"><p><code>Catalyst.assemble_nonlinear_micro_global!</code> is the only assembly routine which mutates the input arguments Jacobi <span>$\mathbf{K}$</span> and residual <span>$\mathbf{f}$</span></p></div></div><article class="docstring"><header><a class="docstring-binding" id="Catalyst.assemble_nonlinear_micro_element!" href="#Catalyst.assemble_nonlinear_micro_element!"><code>Catalyst.assemble_nonlinear_micro_element!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function assemble_nonlinear_micro_element!(ke, ge, cell, cv, ce, Œît, D, Q, k‚Çô, c‚Åø‚Çë)</code></pre><p>assembles the element jacobi for the newton iteration. This function is never called by any user, it will be called by <code>assemble_nonlinear_micro_global!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/Catalyst/blob/705a6bf4ffec26868623e8b5b6be0dd001b764a2/src/micro.jl#L295-L299">source</a></section></article><h2 id="Micro-Solver"><a class="docs-heading-anchor" href="#Micro-Solver">Micro Solver</a><a id="Micro-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Micro-Solver" title="Permalink"></a></h2><p>From a user perspective only <code>catalyst_update</code> is invoked which determines based on the input which micro computation need to be done. In case of an array of arrays holding <code>CatalystStateODE</code>s the update is done based on a suitable ODE. </p><p>If a array of array of <code>CatalystStatePDE</code> is passed, either a linear or nonlinear micro PDE is solved.</p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.catalyst_update!" href="#Catalyst.catalyst_update!"><code>Catalyst.catalyst_update!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">catalyst_update!( cellvalues::CellScalarValues{dim}, dh::DofHandler, c::AbstractVector, Catalysts::Array{Array{CatalystStateODE,1},1}, Œ¥T::Float64, w::Float64)</code></pre><p>updates all <code>CatalystStateODE</code> structs that need to be passed as a arrays of arrays. The first array corresponds to the element index and in each element index there is a nested array for all gauss points holding in each entry a <code>CatalystStateODE</code></p><p>The function then updates the state by the corresponding ordinary differnetial equation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/Catalyst/blob/705a6bf4ffec26868623e8b5b6be0dd001b764a2/src/micro.jl#L75-L81">source</a></section><section><div><pre><code class="language-none">catalyst_update!(cellvalues::CellScalarValues{dim}, dh::DofHandler, c::AbstractVector, Catalysts::Array{Array{CatalystStatePDE,1},1}, t::Number, computation_type::Symbol)</code></pre><p>updates all <code>CatalystStatePDE</code> structs that need to be passed as a arrays of arrays. The first array corresponds to the element index and in each element index there is a nested array for all gauss points holding in each entry a <code>CatalystStatePDE</code></p><p>The function then updates the state by the corresponding partial differnetial equation. the variable <code>computation_type</code> can either be <code>:linear</code> or <code>:nonlinear</code> and thereby determines if a linear or nonlinear PDE is solved. In case of the nonlinear PDE the nonlinearity is introduced by a source/sink term and is in this case the langmuir isotherm formulation.  However can be changed without any big hurdles</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/Catalyst/blob/705a6bf4ffec26868623e8b5b6be0dd001b764a2/src/micro.jl#L106-L113">source</a></section></article><h3 id="Linear-Micro-Solver"><a class="docs-heading-anchor" href="#Linear-Micro-Solver">Linear Micro Solver</a><a id="Linear-Micro-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Micro-Solver" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Catalyst.microcomputation_linear!" href="#Catalyst.microcomputation_linear!"><code>Catalyst.microcomputation_linear!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">micrcomputation_linear!!(c‚Çë::Float64, Catalyst::CatalystStatePDE)</code></pre><p>solves the discretized linear finite element problem with the current macroscopic concentration c‚Çë as the value for the Dirichlet boundary condition. After solving the linear system the previous concentration of the <code>Catalyst</code> is updated to the current solution.</p><p>Besides updating the previous concentration, this function also updates the current flux across the boundary <code>Catalyst.c·µß</code> by looping over all boundary faces and their corresponding gauss points and evaluates there the sum</p><div>\[c_{\Gamma} = \int_{\partial \Omega}(\mathbf{D} \cdot \nabla c)\cdot \mathbf{n}\ dA\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/Catalyst/blob/705a6bf4ffec26868623e8b5b6be0dd001b764a2/src/micro.jl#L136-L147">source</a></section></article><h3 id="Nonlinear-Micro-Solver"><a class="docs-heading-anchor" href="#Nonlinear-Micro-Solver">Nonlinear Micro Solver</a><a id="Nonlinear-Micro-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Micro-Solver" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Catalyst.microcomputation_nonlinear!" href="#Catalyst.microcomputation_nonlinear!"><code>Catalyst.microcomputation_nonlinear!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">micrcomputation_nonlinear!!(c‚Çë::Float64, Catalyst::CatalystStatePDE)</code></pre><p>solves the discretized nonlinear finite element problem with the current macroscopic concentration c‚Çë as the value for the Dirichlet boundary condition. After setting the ConstraintHandler up the nonlinear parts are assembled by <code>assemble_nonlinear_micro_global!</code> and <code>assemble_nonlinear_micro_element!</code>, respectively, within a Newton Iteration loop.</p><p>As soon as the solution of the current time step is found the very same flux across the boundary is computed as in <code>microcomputation_linear!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/Catalyst/blob/705a6bf4ffec26868623e8b5b6be0dd001b764a2/src/micro.jl#L188-L195">source</a></section></article><h2 id="Micro-Source/Sink"><a class="docs-heading-anchor" href="#Micro-Source/Sink">Micro Source/Sink</a><a id="Micro-Source/Sink-1"></a><a class="docs-heading-anchor-permalink" href="#Micro-Source/Sink" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Catalyst.langmuir_isotherm‚Ä≤" href="#Catalyst.langmuir_isotherm‚Ä≤"><code>Catalyst.langmuir_isotherm‚Ä≤</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">langmuir_isotherm‚Ä≤(c¬Ø, Q, k‚Çô)</code></pre><p>computes the first derivative w.r.t. c¬Ø of the langmuir isotherm formulation, where  c¬Ø is the current Newton guess, Q is accordingly to wiki the value that forms the asymptote, k‚Çô is the Langmuir-Sorptioncoefficient. Returns a scalar.</p><div>\[f&#39;(c^-, Q, k_n) = Q\ k_n\ (1+k_n\ c^-)^{-2}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/Catalyst/blob/705a6bf4ffec26868623e8b5b6be0dd001b764a2/src/micro.jl#L326-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.langmuir_isotherm‚Ä≥" href="#Catalyst.langmuir_isotherm‚Ä≥"><code>Catalyst.langmuir_isotherm‚Ä≥</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">langmuir_isotherm‚Ä≥(c¬Ø, Q, k‚Çô)</code></pre><p>computes the second derivative w.r.t. c¬Ø of the langmuir isotherm formulation.</p><div>\[f&#39;&#39;(c^-, Q, k_n) = -2Q\ k_n^2\ (1+k_n\ c^-)^{-3}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/koehlerson/Catalyst/blob/705a6bf4ffec26868623e8b5b6be0dd001b764a2/src/micro.jl#L340-L347">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theory/">¬´ Theory</a><a class="docs-footer-nextpage" href="../../utils/utils/">Utils ¬ª</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 7 July 2020 19:54">Tuesday 7 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
