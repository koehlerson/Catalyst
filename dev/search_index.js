var documenterSearchIndex = {"docs":
[{"location":"utils/utils/#Visualization","page":"Utils","title":"Visualization","text":"","category":"section"},{"location":"utils/utils/","page":"Utils","title":"Utils","text":"Catalyst.plotAnimation\nCatalyst.plotOverTime","category":"page"},{"location":"utils/utils/#Catalyst.plotAnimation","page":"Utils","title":"Catalyst.plotAnimation","text":"plotAnimation(storage::Array, gifname::String, lim=(0,1))\n\nPlots a collection of one dimensional arrays to a gif. Applicable to plot the Reaction Operator or the one dimensional concentration field at each time instance  over the domain. Both mentioned things are returned by Catalyst.solve(...) \n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#Catalyst.plotOverTime","page":"Utils","title":"Catalyst.plotOverTime","text":"plotOverTime(storage::Array, ylim=(0,1), save=false, figname=missing)\n\ntakes the last entry of the storage array in each time step and plots it over time. Useful to plot the concentration field returned by Catalyst.solve() over time.\n\n\n\n\n\n","category":"function"},{"location":"utils/utils/#I/O","page":"Utils","title":"I/O","text":"","category":"section"},{"location":"utils/utils/","page":"Utils","title":"Utils","text":"Catalyst.save1D","category":"page"},{"location":"utils/utils/#Catalyst.save1D","page":"Utils","title":"Catalyst.save1D","text":"save1D(storage::Array, savename::String, path::String; headername=\"data\")\n\nwrites a one dimensional field to disk by providing the field in storage, a savename as String and a path.\n\n\n\n\n\n","category":"function"},{"location":"micro/theory/#Non-Linear-Microproblem","page":"Theory","title":"Non-Linear Microproblem","text":"","category":"section"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"fracpartial cpartial t = nabla cdot (mathbfD nabla c) - fracpartial f(c)partial t","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"Applying chain rule to fracpartial fpartial t yields","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"fracpartial cpartial t = nabla cdot (mathbfD nabla c) - fracpartial f(c)partial cfracpartial cpartial t","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"Discretizing the time derivative by means of an implicit Euler scheme leads to","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"c^n+1 - Delta t nabla cdot (mathbfD nabla c^n+1) + fracpartial f(c^n+1)partial c^n+1 (c^n+1-c^n) - c^n = 0","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"Integrating over domain Omega and multiplying test function v results in","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"F=int_Omega c^n+1  v + Delta t  nabla v^T mathbfD nabla c^n+1 + fracpartial f(c^n+1)partial c^n+1(c^n+1-c^n) v-c^n v =0","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"Using the following definitions","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"c= sum_j^n phi_i c_i","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"v = phi_j qquad textsince  forall  v in V_h","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"f= fracQk_nc1+k_n c","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"fracpartial f(c)partial c = f(c)=fracQ k_n(1+k_n c)^2 = Qk_n(1+k_nc)^-2","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"fracpartial^2 f(c)partial c^2 =f(c)= -2Qk_n^2(1+k_n c)^-3","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"we obtain the nonlinear problem with Jacobian","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"J_ij = fracpartial F_ipartial c_i = int_Omega phi_iphi_j + Delta t nabla phi_j ^T mathbfD nabla phi_i + f(c^-) phi_i phi_j + f(c^-)c^-phi_i phi_j - f(c^-)c^nphi_iphi_j","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"with c^- being the most recent Newton approximation. ","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"mathbfJ mathbfDelta c = -mathbfF(c^-)","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"mathbfc = mathbfc^- + omega mathbfDelta c","category":"page"},{"location":"micro/theory/","page":"Theory","title":"Theory","text":"mathbfc^-leftarrow mathbfc","category":"page"},{"location":"macro/assembly/","page":"Assembly","title":"Assembly","text":"This page covers assembly routines that are used for the macroscopic problem.  The interface of all assembly routines is the same in that sense that, depending on the input arguments (multiple dispatch) doassemble returns a discrete FE Operator which can be used to set up the linear system of equation or the differential algebraic equation in time, respectively.","category":"page"},{"location":"macro/assembly/","page":"Assembly","title":"Assembly","text":"More about the usage with the discrete operators can be found in the solver section.","category":"page"},{"location":"macro/assembly/","page":"Assembly","title":"Assembly","text":"doassemble\nCatalyst.volume","category":"page"},{"location":"macro/assembly/#Catalyst.doassemble","page":"Assembly","title":"Catalyst.doassemble","text":"doassemble(w, Œ¥T, cellvalues, M, dh)\n\nReturns M the mass matrix\n\nM_ij = int_Omega phi_icdot v_j  dV\n\nwhere v_j is either the test function of a Galerkin phi_j or Petrov-Galerkin discretization phi_j + delta_T mathbfwcdot nabla phi_j. Can be controlled by the stabilization Parameter delta_T. \n\n\n\n\n\ndoassemble(D, w, Œ¥T, cellvalues, K, dh, R)\n\nReturns K the diffusion and advection matrix and integrates given R reaction operator over finite element space\n\nK = int_Omega (Dcdot nabla phi_i)cdot nabla phi_j dV + int_Omega mathbfw cdot nabla phi_i  phi_j dV\n\nR = int_Omega R phi_i dV\n\n\n\n\n\ndoassemble(Catalysts::Array{Array{CatalystStateODE,1},1}, w, Œ¥T, cellvalues, dh)\n\nReturns the assembled, linearized reaction Operator where in each material point an ODE is solved\n\nR = int_Omega k(overlinec - c) phi_i dV\n\n\n\n\n\ndoassemble(Catalysts::Array{Array{CatalystStatePDE,1},1}, w, Œ¥T, cellvalues, dh)\n\nReturns the assembled, nonlinear reaction Operator where in each material point a linear or nonlinear PDE is solved\n\nR = int_Omega k  c_Gamma  phi_i  dV\n\n\n\n\n\n","category":"function"},{"location":"macro/assembly/#Catalyst.volume","page":"Assembly","title":"Catalyst.volume","text":"volume(dh, cv)\n\nComputes the volume of a finite element discretized domain.\n\nV = int_Omega 1  dV\n\n\n\n\n\n","category":"function"},{"location":"micro/implementation/#Structs","page":"Implementation","title":"Structs","text":"","category":"section"},{"location":"micro/implementation/","page":"Implementation","title":"Implementation","text":"Suitable datastructures are developed that hold as their fields all information about the microstructure.  In case of the simplified, linerized sink term CatalystStateODE can be used to store various numbers associated with the catalyst state.  When a PDE description of the microscale is used CatalystStatePDE should be used. This struct assembles by a given micro diffusion the corresponding linear operators of the micro scale and optionally assembles in each catalyst_update! call the nonlinear parts if :nonlinear is passed as the microcomp_type. ","category":"page"},{"location":"micro/implementation/","page":"Implementation","title":"Implementation","text":"CatalystStateODE\nCatalystStatePDE","category":"page"},{"location":"micro/implementation/#Catalyst.CatalystStateODE","page":"Implementation","title":"Catalyst.CatalystStateODE","text":"CatalystStateODE(D_i, k·µß, k, h, r, V, A, Œît, coeff, c·µß_old)\n\ninstantiates a CatalystStateODE struct holding all necessary values for the simplified microscale formulation\n\n\n\n\n\n","category":"type"},{"location":"micro/implementation/#Catalyst.CatalystStatePDE","page":"Implementation","title":"Catalyst.CatalystStatePDE","text":"CatalystStatePDE(D_i, k_Œ≥, mesh, Q, k‚Çô)\n\nconstructs a CatalystStatePDE struct that stores all information about the microstructure. Therefore, assembles also the linear diffusion and mass matrices that are stored in M, K and their associated sum in A=K+k_Œ≥*M\n\n\n\n\n\n","category":"type"},{"location":"micro/implementation/#Assembly","page":"Implementation","title":"Assembly","text":"","category":"section"},{"location":"micro/implementation/","page":"Implementation","title":"Implementation","text":"Most of the assembly is handled while constructing the corresponding CatalystState struct. However, in case of a nonlinear computation the nonlinear parts, i.e. the Jacobian of the residual has to be assembled in each newton iteration, due to its nonlinear nature.","category":"page"},{"location":"micro/implementation/","page":"Implementation","title":"Implementation","text":"Catalyst.assemble_nonlinear_micro_global!","category":"page"},{"location":"micro/implementation/#Catalyst.assemble_nonlinear_micro_global!","page":"Implementation","title":"Catalyst.assemble_nonlinear_micro_global!","text":"function assemble_nonlinear_micro_global!(K::SparseMatrixCSC{Float64,Int64}, f::Array{Float64,1}, dh::DofHandler, cv::CellScalarValues, c::Array{Float64,1}, Œît, D, Q, k‚Çô, c‚Åø, ùêÄ::SparseMatrixCSC{Float64,Int64})\n\nAssembles only the nonlinear part of the jacobian, so needs to add the linear part after nonlinear assemble, i.e.  assemble jacobi K, add mass matrix M and Diffusion Matrix Catalyst.K (ùêÄ) on top \n\n\n\n\n\n","category":"function"},{"location":"micro/implementation/","page":"Implementation","title":"Implementation","text":"note: Care the interface\nCatalyst.assemble_nonlinear_micro_global! is the only assembly routine which mutates the input arguments Jacobi mathbfK and residual mathbff","category":"page"},{"location":"micro/implementation/","page":"Implementation","title":"Implementation","text":"Catalyst.assemble_nonlinear_micro_element!","category":"page"},{"location":"micro/implementation/#Catalyst.assemble_nonlinear_micro_element!","page":"Implementation","title":"Catalyst.assemble_nonlinear_micro_element!","text":"function assemble_nonlinear_micro_element!(ke, ge, cell, cv, ce, Œît, D, Q, k‚Çô, c‚Åø‚Çë)\n\nassembles the element jacobi for the newton iteration. This function is never called by any user, it will be called by assemble_nonlinear_micro_global!\n\n\n\n\n\n","category":"function"},{"location":"micro/implementation/#Micro-Solver","page":"Implementation","title":"Micro Solver","text":"","category":"section"},{"location":"micro/implementation/","page":"Implementation","title":"Implementation","text":"From a user perspective only catalyst_update is invoked which determines based on the input which micro computation need to be done. In case of an array of arrays holding CatalystStateODEs the update is done based on a suitable ODE. ","category":"page"},{"location":"micro/implementation/","page":"Implementation","title":"Implementation","text":"If a array of array of CatalystStatePDE is passed, either a linear or nonlinear micro PDE is solved.","category":"page"},{"location":"micro/implementation/","page":"Implementation","title":"Implementation","text":"Catalyst.catalyst_update!","category":"page"},{"location":"micro/implementation/#Catalyst.catalyst_update!","page":"Implementation","title":"Catalyst.catalyst_update!","text":"catalyst_update!( cellvalues::CellScalarValues{dim}, dh::DofHandler, c::AbstractVector, Catalysts::Array{Array{CatalystStateODE,1},1}, Œ¥T::Float64, w::Float64)\n\nupdates all CatalystStateODE structs that need to be passed as a arrays of arrays. The first array corresponds to the element index and in each element index there is a nested array for all gauss points holding in each entry a CatalystStateODE\n\nThe function then updates the state by the corresponding ordinary differnetial equation\n\n\n\n\n\ncatalyst_update!(cellvalues::CellScalarValues{dim}, dh::DofHandler, c::AbstractVector, Catalysts::Array{Array{CatalystStatePDE,1},1}, t::Number, computation_type::Symbol)\n\nupdates all CatalystStatePDE structs that need to be passed as a arrays of arrays. The first array corresponds to the element index and in each element index there is a nested array for all gauss points holding in each entry a CatalystStatePDE\n\nThe function then updates the state by the corresponding partial differnetial equation. the variable computation_type can either be :linear or :nonlinear and thereby determines if a linear or nonlinear PDE is solved. In case of the nonlinear PDE the nonlinearity is introduced by a source/sink term and is in this case the langmuir isotherm formulation.  However can be changed without any big hurdles\n\n\n\n\n\n","category":"function"},{"location":"micro/implementation/#Linear-Micro-Solver","page":"Implementation","title":"Linear Micro Solver","text":"","category":"section"},{"location":"micro/implementation/","page":"Implementation","title":"Implementation","text":"Catalyst.microcomputation_linear!","category":"page"},{"location":"micro/implementation/#Catalyst.microcomputation_linear!","page":"Implementation","title":"Catalyst.microcomputation_linear!","text":"micrcomputation_linear!!(c‚Çë::Float64, Catalyst::CatalystStatePDE)\n\nsolves the discretized linear finite element problem with the current macroscopic concentration c‚Çë as the value for the Dirichlet boundary condition. After solving the linear system the previous concentration of the Catalyst is updated to the current solution.\n\nBesides updating the previous concentration, this function also updates the current flux across the boundary Catalyst.c·µß by looping over all boundary faces and their corresponding gauss points and evaluates there the sum\n\nc_Gamma = int_partial Omega(mathbfD cdot nabla c)cdot mathbfn dA\n\n\n\n\n\n","category":"function"},{"location":"micro/implementation/#Nonlinear-Micro-Solver","page":"Implementation","title":"Nonlinear Micro Solver","text":"","category":"section"},{"location":"micro/implementation/","page":"Implementation","title":"Implementation","text":"Catalyst.microcomputation_nonlinear!","category":"page"},{"location":"micro/implementation/#Catalyst.microcomputation_nonlinear!","page":"Implementation","title":"Catalyst.microcomputation_nonlinear!","text":"micrcomputation_nonlinear!!(c‚Çë::Float64, Catalyst::CatalystStatePDE)\n\nsolves the discretized nonlinear finite element problem with the current macroscopic concentration c‚Çë as the value for the Dirichlet boundary condition. After setting the ConstraintHandler up the nonlinear parts are assembled by assemble_nonlinear_micro_global! and assemble_nonlinear_micro_element!, respectively, within a Newton Iteration loop.\n\nAs soon as the solution of the current time step is found the very same flux across the boundary is computed as in microcomputation_linear!.\n\n\n\n\n\n","category":"function"},{"location":"micro/implementation/#Micro-Source/Sink","page":"Implementation","title":"Micro Source/Sink","text":"","category":"section"},{"location":"micro/implementation/","page":"Implementation","title":"Implementation","text":"Catalyst.langmuir_isotherm‚Ä≤\nCatalyst.langmuir_isotherm‚Ä≥","category":"page"},{"location":"micro/implementation/#Catalyst.langmuir_isotherm‚Ä≤","page":"Implementation","title":"Catalyst.langmuir_isotherm‚Ä≤","text":"langmuir_isotherm‚Ä≤(c¬Ø, Q, k‚Çô)\n\ncomputes the first derivative w.r.t. c¬Ø of the langmuir isotherm formulation, where  c¬Ø is the current Newton guess, Q is accordingly to wiki the value that forms the asymptote, k‚Çô is the Langmuir-Sorptioncoefficient. Returns a scalar.\n\nf(c^- Q k_n) = Q k_n (1+k_n c^-)^-2\n\n\n\n\n\n","category":"function"},{"location":"micro/implementation/#Catalyst.langmuir_isotherm‚Ä≥","page":"Implementation","title":"Catalyst.langmuir_isotherm‚Ä≥","text":"langmuir_isotherm‚Ä≥(c¬Ø, Q, k‚Çô)\n\ncomputes the second derivative w.r.t. c¬Ø of the langmuir isotherm formulation.\n\nf(c^- Q k_n) = -2Q k_n^2 (1+k_n c^-)^-3\n\n\n\n\n\n","category":"function"},{"location":"#Catalyst.jl","page":"Home","title":"Catalyst.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The research project of the Chair of Mechanics - Continuum Mechanics Ruhr-University Bochum in collaboration with Hirshikesh Joshi from the Max Planck Institute for Coal Research","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package gathers all developed finite element discretizations for a suitable description of the underlying mass transport experiment explained in Koh et al.[1998].  Besides solving a discretized problem with given experimental input, it is also able to calibrate the instantiated model against experiment data by means of an optimization. For the optimization the python package cma from Nikolaus Hansen is used. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The experiment data that we try to described looks for instance like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Experiment Data)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where Experiment Input serves as the dynamic Dirichlet boundary condition for the model. Here Experiment Output can optionally be used as a target function for the model and thus, is used for calibration as the reference curve.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The continuous model in this package relies heavily on continuum mechanical principles and so, assumes that the continuum assumption is valid. In this package the discretized partial differential equation is the advection-diffusion-reaction (ADR) equation, which finds versatile usage in fluid mechanics.  It describes the transport of a scalar quantity (mass, concentration, ..) in terms of two mechanisms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"advection by a given velocity field overlinemathbfw \ndiffusion by a given constitutive equation, e.g. Fick's law and given Diffusion tensor overlinemathbfD","category":"page"},{"location":"","page":"Home","title":"Home","text":"Besides the two mentioned mechanisms the scalar transport can be created or destroyed by a suitable sink/source term.   In the scope of the ADR equation this source/sink term is called reaction term overlineR and serves within this paper as the scale bridging operator. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The strong form of the ADR is given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracpartial overlinecpartial t = nabla cdot (overlinemathbfD nabla overlinec) - nabla (overlinemathbfw overlinec)+overlineR","category":"page"},{"location":"","page":"Home","title":"Home","text":"and discretized by finite elements in the weak form by integrating the strong form over the computational domain overlineOmega and multiplying a test function overlinev ","category":"page"},{"location":"","page":"Home","title":"Home","text":"int_overlineOmegafracpartialoverlinecpartial toverlinev text dV +int_overlineOmega mathbfw cdot  nabla overlinec overlinevtext dV + int_overlineOmega nabla overlinec^textT cdot overlinemathbfDnabla overlinevtext dV  = int_overlineOmegaR overlinevtext dV","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation page is the starting point to understand the underlying algorithms of the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation is mainly structured in three topics: macroscopic, microscopic and utils code. It is suggested to start with the macroscopic section, then reading the microscopic part and optionally end with the utils section.","category":"page"},{"location":"macro/solver/#Theory","page":"Solver","title":"Theory","text":"","category":"section"},{"location":"macro/solver/","page":"Solver","title":"Solver","text":"After assembling the discrete FE operators we are left with large system of ODEs in time, i.e.","category":"page"},{"location":"macro/solver/","page":"Solver","title":"Solver","text":"mathbfM mathbfc(t) + mathbfA mathbfc(t) = mathbfr(mathbfc)","category":"page"},{"location":"macro/solver/","page":"Solver","title":"Solver","text":"where mathbfM mathbfA and mathbfr represents the assembled mass matrix, diffusion & advection matrices and reaction operator, respectively.  In this represenation it should become clear why we are left with a system of ODEs. Furthermore note that the reaction operator is dependent of the current solution of c and thus introduces a non-linearity.","category":"page"},{"location":"macro/solver/","page":"Solver","title":"Solver","text":"This non-linearity is right now bypassed by an operator splitting and in this particular case by an sequential solving. So, we first solve the nonlinear micro and then use it and solve the linear problem.","category":"page"},{"location":"macro/solver/#Implementation","page":"Solver","title":"Implementation","text":"","category":"section"},{"location":"macro/solver/","page":"Solver","title":"Solver","text":"Catalyst.solve","category":"page"},{"location":"macro/solver/#Catalyst.solve","page":"Solver","title":"Catalyst.solve","text":"solve(D·µ¢::Float64, k::Float64, k·µß::Float64, \n    input_exp::Array, output_exp::Array;\n    N=(100,), L=5e-2, w=1.9128e-4 * (1 / 0.37), \n    T = 1000, Œît=1, D‚Çë=1e-9, r·µ¢=2.15e-7, \n    h= L/N[1], Œ¥T = h/(2 * abs(w)),\n    progress=true, calibration=false,\n    microsave=false, microsave_time = (250, 300, 350, 400),\n    microsave_location=((10,1), (50,1), (80,1)),\n    microcomp_type=:linear,\n    Q=0., k‚Çô=0.,\n    micromesh=Parser.getGrid(projectdir(\"test/catalyst.msh\")))\n\nis the main function of the package which starts a FE computation with nested  FE computations in material points. Sets up the finite element spaces, discretizes the operators, applies boundary conditions and solves the time dependent problem in a loop.\n\nArguments\n\nD·µ¢::Float64: is the microscopic diffusion. \nk::Float64, k·µß::Float64, Q::Float64, k‚Çô::Float64: are microscopic parameters.\ninput_exp::Array, output_exp::Array: are the experiment measurements.\nprogress::Bool: enables/disables a progress bar for the macroscopic time steps.\ncalibration::Bool: enables/disables a returned error between the last node concentration and the output experiment concentration.\nmicrosave::Bool, microsave_time::Tuple and microsave_location::Tuple: controls which times and locations of the microscopic problems are saved to the disk\nmicrocomp_type::Symbol: decides whether or not linear or nonlinear micro computations are done.\nmicromesh::JuAFEM.Grid: describes the microscopic domain.\n\nReturns either two arrays, one dimensional concentration field c at each time step and the assembled reaction operator at each time step or returns the squarred error (scalar).\n\n\n\n\n\n","category":"function"}]
}
